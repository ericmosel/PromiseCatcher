// Generated by CoffeeScript 1.10.0
(function() {
  var PromiseCatcher;

  PromiseCatcher = (function() {
    var Fs, Path, Promise, cachePath, candidateQueue, candidateQueueLength, candidateRequestThreshold, cleanCache, debugMode, getCache, isCandidate, liveCacheItems, maxCacheItems, setCache;

    Promise = require('promise');

    Path = require('path');

    Fs = require('fs');

    liveCacheItems = {
      metaData: [],
      ids: [],
      count: 0
    };

    candidateQueue = {
      requestCount: [],
      ids: []
    };

    debugMode = true;

    cachePath = '';

    maxCacheItems = 256;

    candidateQueueLength = 40;

    candidateRequestThreshold = 2;

    function PromiseCatcher(options) {
      var index;
      if (options.cachePath == null) {
        options.cachePath = '';
      }
      if (options.ttl == null) {
        options.ttl = 240;
      }
      if (options.maxCacheItems == null) {
        options.maxCacheItems = 256;
      }
      if (options.candidateQueueLength == null) {
        options.candidateQueueLength = 40;
      }
      if (options.candidateRequestThreshold == null) {
        options.candidateRequestThreshold = 2;
      }
      if (options.debug == null) {
        options.debug = false;
      }
      debugMode = options.debug;
      cachePath = options.cachePath + 'promises' + Path.sep;
      maxCacheItems = options.maxCacheItems;
      candidateQueueLength = options.candidateQueueLength;
      candidateRequestThreshold = options.candidateRequestThreshold;
      index = 0;
      while (index++ < candidateQueueLength) {
        candidateQueue.ids.push('');
        candidateQueue.requestCount.push(0);
      }
      cachePath = options.cachePath + 'promises' + Path.sep;
      maxCacheItems = options.maxCacheItems;
      if (Fs.existsSync(cachePath)) {
        Fs.readdirSync(cachePath).forEach(function(file, index) {
          var curPath;
          curPath = cachePath + file;
          return Fs.unlinkSync(curPath);
        });
      } else {
        Fs.mkdir(cachePath);
      }
    }

    PromiseCatcher.prototype.GetCache = function(id, promisesToCache) {
      var indexMetaData, item, promiseIndex, promises;
      promises = [];
      if (liveCacheItems.ids[id] !== void 0) {
        indexMetaData = liveCacheItems.ids[id];
        item = liveCacheItems.metaData[indexMetaData];
        if ('' + item.id === '' + id) {
          promises = getCache(id, promisesToCache);
        } else {
          promiseIndex = 0;
          while (promiseIndex < promisesToCache.length) {
            promises.push(promisesToCache[promiseIndex]);
            promiseIndex++;
          }
        }
      } else {
        promiseIndex = 0;
        while (promiseIndex < promisesToCache.length) {
          promises.push(promisesToCache[promiseIndex]);
          promiseIndex++;
        }
      }
      return promises;
    };

    PromiseCatcher.prototype.SetCache = function(id, data) {
      return setCache(id, data);
    };

    getCache = function(id, promisesToCache) {
      var dataIndex, returnPromises;
      returnPromises = [];
      dataIndex = -1;
      while (++dataIndex < promisesToCache.length) {
        returnPromises.push(new Promise(function(fulfill, reject) {
          return Fs.readFile("" + cachePath + id + "_" + dataIndex, function(err, data) {
            var cachedData, indexMetaData;
            if (err != null) {
              console.log(err);
              return fulfill([]);
            } else {
              indexMetaData = liveCacheItems.ids[id];
              liveCacheItems.metaData[indexMetaData].lastUsed = Date.now();
              cachedData = JSON.parse(data);
              cachedData.fromPromiseCatcher = true;
              return fulfill(cachedData);
            }
          });
        }));
      }
      return returnPromises;
    };

    setCache = function(id, data) {
      var dataIndex, results;
      if (isCandidate(candidateQueue, id)) {
        Fs.writeFile("" + cachePath + id + "_0", JSON.stringify(data[0]), function(err, data) {
          if (err != null) {
            return console.log(err);
          } else {
            if (liveCacheItems.count >= maxCacheItems) {
              cleanCache(maxCacheItems);
            }
            liveCacheItems.ids[id] = liveCacheItems.metaData.length;
            ++liveCacheItems.count;
            liveCacheItems.metaData.push({
              id: id,
              lastUsed: Date.now()
            });
            if (debugMode) {
              return console.log(liveCacheItems);
            }
          }
        });
        dataIndex = 0;
        results = [];
        while (++dataIndex < data.length) {
          results.push(Fs.writeFile("" + cachePath + id + "_" + dataIndex, JSON.stringify(data[dataIndex]), function(err, data) {
            if (err != null) {
              return console.log(err);
            }
          }));
        }
        return results;
      }
    };

    cleanCache = function() {
      var indexMetaData;
      liveCacheItems.metaData.sort(function(a, b) {
        return b.lastUsed - a.lastUsed;
      });
      liveCacheItems.metaData.length = Math.floor(maxCacheItems / 4);
      liveCacheItems.ids = [];
      liveCacheItems.count = 0;
      indexMetaData = 0;
      while (indexMetaData < liveCacheItems.metaData.length) {
        liveCacheItems.ids[liveCacheItems.metaData[indexMetaData].id] = indexMetaData++;
      }
      return liveCacheItems.count = indexMetaData;
    };

    isCandidate = function(candidateQueue, id) {
      var candidateIndex, candidateRequestCount;
      candidateIndex = candidateQueue.ids.indexOf(id);
      if (candidateIndex !== -1) {
        candidateRequestCount = ++candidateQueue.requestCount[candidateIndex];
      } else {
        candidateIndex = candidateQueue.ids.push(id);
        candidateRequestCount = 1;
        candidateIndex = candidateQueue.requestCount.push(candidateRequestCount);
        candidateQueue.ids.shift();
        candidateQueue.requestCount.shift();
      }
      if (debugMode) {
        console.log(candidateQueue);
      }
      return candidateRequestCount > candidateRequestThreshold;
    };

    return PromiseCatcher;

  })();

  module.exports = PromiseCatcher;

}).call(this);
