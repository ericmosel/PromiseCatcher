// Generated by CoffeeScript 1.10.0
(function() {
  var PromiseCatcher;

  PromiseCatcher = (function() {
    var Fs, Path, Promise, cachePath, cacheTimeToLive, candidateQueue, candidateQueueLength, candidateRequestThreshold, cleanCache, clearCacheSizeFraction, debugMode, getCache, instancePrivateClass, isCandidate, liveCacheItems, maxCacheItems, sendBackPromises, setCache, thisInstance;

    function PromiseCatcher() {}

    Promise = require('promise');

    Path = require('path');

    Fs = require('fs');

    thisInstance = null;

    liveCacheItems = {
      metaData: [],
      ids: [],
      count: 0
    };

    candidateQueue = {
      requestCount: [],
      ids: []
    };

    debugMode = true;

    cachePath = '';

    maxCacheItems = 1024;

    clearCacheSizeFraction = 4;

    candidateQueueLength = 20;

    candidateRequestThreshold = 2;

    cacheTimeToLive = 0;

    PromiseCatcher.Instance = function(options) {
      return thisInstance != null ? thisInstance : thisInstance = new instancePrivateClass(options);
    };

    instancePrivateClass = (function() {
      function instancePrivateClass(options) {
        var index;
        if (options.cachePath == null) {
          options.cachePath = '';
        }
        if (options.ttl == null) {
          options.ttl = 0;
        }
        if (options.maxCacheItems == null) {
          options.maxCacheItems = 1024;
        }
        if (options.clearCacheSizeFraction == null) {
          options.clearCacheSizeFraction = 4;
        }
        if (options.candidateQueueLength == null) {
          options.candidateQueueLength = 20;
        }
        if (options.candidateRequestThreshold == null) {
          options.candidateRequestThreshold = 2;
        }
        if (options.debug == null) {
          options.debug = false;
        }
        debugMode = options.debug;
        cachePath = options.cachePath + 'promises' + Path.sep;
        maxCacheItems = options.maxCacheItems;
        clearCacheSizeFraction = options.clearCacheSizeFraction;
        candidateQueueLength = options.candidateQueueLength;
        candidateRequestThreshold = options.candidateRequestThreshold;
        options.ttl;
        index = 0;
        while (index++ < candidateQueueLength) {
          candidateQueue.ids.push('');
          candidateQueue.requestCount.push(0);
        }
        if (Fs.existsSync(cachePath)) {
          Fs.readdirSync(cachePath).forEach(function(file, index) {
            var curPath;
            curPath = cachePath + file;
            return Fs.unlinkSync(curPath);
          });
        } else {
          Fs.mkdir(cachePath);
        }
      }

      instancePrivateClass.prototype.GetCache = function(id, promisesToCache) {
        var indexMetaData, item, promises;
        id = require('crypto').createHash('sha1').update('' + id).digest("hex");
        promises = null;
        if (liveCacheItems.ids[id] !== void 0) {
          indexMetaData = liveCacheItems.ids[id];
          item = liveCacheItems.metaData[indexMetaData];
          if (item.id === id) {
            promises = getCache(id, promisesToCache);
          } else {
            if (debugMode) {
              console.log('corrupt ' + id);
              console.log(item);
              console.log(liveCacheItems.metaData[indexMetaData + 1]);
              console.log(liveCacheItems.metaData[indexMetaData - 1]);
            }
            promises = sendBackPromises(promisesToCache);
          }
        } else {
          promises = sendBackPromises(promisesToCache);
        }
        return promises;
      };

      instancePrivateClass.prototype.SetCache = function(id, data, ttl) {
        id = require('crypto').createHash('sha1').update('' + id).digest("hex");
        if (ttl == null) {
          ttl = cacheTimeToLive;
        }
        return setCache(id, data, ttl);
      };

      return instancePrivateClass;

    })();

    getCache = function(id, promisesToCache) {
      var dataIndex, returnPromises;
      returnPromises = null;
      if (promisesToCache.length > 0) {
        returnPromises = [];
        dataIndex = -1;
        while (++dataIndex < promisesToCache.length) {
          returnPromises.push(new Promise(function(fulfill, reject) {
            var thisIndex;
            thisIndex = dataIndex;
            return Fs.readFile("" + cachePath + id, function(err, data) {
              var cachedData, indexMetaData;
              if (err != null) {
                console.log(err);
                return fulfill(promisesToCache);
              } else {
                indexMetaData = liveCacheItems.ids[id];
                liveCacheItems.metaData[indexMetaData].lastUsed = Date.now();
                cachedData = JSON.parse(data);
                cachedData[thisIndex].IsFromPromiseCatcher = true;
                return fulfill(cachedData[thisIndex]);
              }
            });
          }));
        }
      } else {
        returnPromises = new Promise(function(fulfill, reject) {
          return Fs.readFile("" + cachePath + id, function(err, data) {
            var cachedData, indexMetaData;
            if (err != null) {
              console.log(err);
              return fulfill(promisesToCache);
            } else {
              indexMetaData = liveCacheItems.ids[id];
              liveCacheItems.metaData[indexMetaData].lastUsed = Date.now();
              cachedData = JSON.parse(data);
              cachedData.IsFromPromiseCatcher = true;
              return fulfill(cachedData);
            }
          });
        });
      }
      return returnPromises;
    };

    setCache = function(id, data, ttl) {
      if (isCandidate(candidateQueue, id)) {
        return Fs.writeFile("" + cachePath + id, JSON.stringify(data), function(err, data) {
          var indexMetaData;
          if (err != null) {
            return console.log(err);
          } else {
            if (liveCacheItems.count >= maxCacheItems) {
              cleanCache(maxCacheItems);
            }
            if (liveCacheItems.ids[id] === void 0) {
              indexMetaData = liveCacheItems.metaData.push({
                id: id,
                lastUsed: Date.now()
              });
              liveCacheItems.ids[id] = indexMetaData - 1;
              ++liveCacheItems.count;
            } else {
              liveCacheItems.metaData[liveCacheItems.ids[id]].lastUsed = Date.now();
            }
            if (debugMode) {
              return console.log(liveCacheItems);
            }
          }
        });
      }
    };

    cleanCache = function() {
      var indexMetaData;
      liveCacheItems.metaData.sort(function(a, b) {
        return b.lastUsed - a.lastUsed;
      });
      liveCacheItems.metaData.length = Math.floor(maxCacheItems / clearCacheSizeFraction);
      liveCacheItems.ids = [];
      liveCacheItems.count = 0;
      indexMetaData = 0;
      while (indexMetaData < liveCacheItems.metaData.length) {
        liveCacheItems.ids[liveCacheItems.metaData[indexMetaData].id] = indexMetaData++;
      }
      return liveCacheItems.count = indexMetaData;
    };

    isCandidate = function(candidateQueue, id) {
      var candidateIndex, candidateRequestCount;
      candidateIndex = candidateQueue.ids.indexOf(id);
      if (candidateIndex !== -1) {
        candidateRequestCount = ++candidateQueue.requestCount[candidateIndex];
      } else {
        candidateIndex = candidateQueue.ids.push(id);
        candidateRequestCount = 1;
        candidateIndex = candidateQueue.requestCount.push(candidateRequestCount);
        candidateQueue.ids.shift();
        candidateQueue.requestCount.shift();
      }
      if (debugMode) {
        console.log(candidateQueue);
      }
      return candidateRequestCount > candidateRequestThreshold;
    };

    sendBackPromises = function(promisesToCache) {
      var promiseIndex, promisesToReturn;
      promisesToReturn = null;
      if (promisesToCache.length > 0) {
        promisesToReturn = [];
        promiseIndex = 0;
        while (promiseIndex < promisesToCache.length) {
          promisesToReturn.push(promisesToCache[promiseIndex]);
          promiseIndex++;
        }
      } else {
        promisesToReturn = promisesToCache;
      }
      return promisesToReturn;
    };

    return PromiseCatcher;

  })();

  module.exports = PromiseCatcher;

}).call(this);
